# AUTOGENERATED! DO NOT EDIT! File to edit: notebooks/04_hazard_function.ipynb (unless otherwise specified).

__all__ = ['estimate_hazard_fun']

# Cell
import matplotlib.pyplot as plt
import matplotlib as mpl
import numpy as np
from scipy import stats
from functools import partial
import statsmodels.formula.api as smf
import pandas as pd

# Cell
def estimate_hazard_fun(df:pd.DataFrame, dep_var:str, idp_var:str, fill:int=0):
    """Estimates the hazard function using the dependent variable `dep_var` and the independent
    variable `idp_var`, assuming the former is binary"""
    assert df[dep_var].nunique() == 2
    df0 = df.loc[df[dep_var]==0, [idp_var]]
    df1 = df.loc[df[dep_var]==1, [idp_var]]

    n = len(df)
    print(f"dep_var '{dep_var}' shares: 0 = {len(df0)/n}, 1 = {len(df1)/n}")

    count_and_rename = lambda _df: _df.groupby(idp_var).size().reset_index().rename(columns={0: "count"})
    hist0 = count_and_rename(df0)
    hist1 = count_and_rename(df1)

    # joining the two counts
    hf = pd.DataFrame(hist0).join(hist1.set_index(idp_var), on=idp_var, how="outer", lsuffix="_0", rsuffix="_1")
    hf.sort_values("age", ascending=True, inplace=True)
    # cleaning nans
    hf.fillna(fill, inplace=True)

    # core computing
    hf["survivors"] = [n] + list(n - (hf["count_0"] + hf["count_1"]).cumsum().values[:-1])
    hf["hazard_function"] = hf["count_1"] / hf["survivors"]
    hf["survival_function"] = (1-hf["hazard_function"]).cumprod()
    # hf["survival_function"] = np.exp((-np.log1p(hf["hazard_function"])).cumsum())
    hf["cdf"] = 1. - hf["survival_function"]
    hf["event_frequency"] = hf["count_1"] / (hf["count_0"] + hf["count_1"])
    dt = np.diff(hf[idp_var])[0]
    hf["sf_int"] = [hf["survival_function"].values[_i:].sum()*dt for _i in range(len(hf))]
    hf["expected_survival"] = hf["sf_int"] / hf["survival_function"]

    return hf